webrocket(7)
============

NAME
----
webrocket - The WebRocket server core library

SYNOPSIS
--------
`import "webrocket"`

DESCRIPTION
-----------
This Go language library contains the core functionality of the
WebRocket server. The *webrocket-server*(1) implements a ready to
use server application based on the *webrocket*(7) library.

ARCHITECTURE
------------
WebRocket is a hybrid of 2 interfaces: the 'WebSockets server' and
the 'MQ exchange server'. In the middle, everything is tied with
internal channels, which allows for easy clustering and hence
horizontal scalability.

WebRocket bridge keeps distributed, bidirectional connection between the
browser and the backend instances using combination of the 'WebSockets
server' and 'the ZeroMQ exchange', connected by internal channels.

The following schema explains it more accurately:

-----
 
    +---------+                    +-------------------+
    | Browser | <----------------> |                   |
    +---------+     WEBSOCKETS     | WebSockets SERVER |
    | Browser | <----------------> |                   |          +---------+
    +---------+                    +---------|---------+ )------> | Logging |
    +---------+                    |  ZeroMQ EXCHANGE  |          +---------+
                                   +-------------------+
                    +---------+              ^
                    | +---------+            |
                    +-| BACKEND | <----------+
                      +---------+

-----

VHosts
~~~~~~
Server is divided into independent 'vhosts'. Each 'vhost' defines
its own 'channels' and 'users', and allows for specific access control
management.

Channels
~~~~~~~~
WebRocket 'channels' are used for broadcasting information across
many clients. Each 'channel' allows 'users' to connect and subscribe
its activity.

Users
~~~~~
The 'user' is defined within 'vhost', so the same user names can
be duplicated in the server instance.

Permissions
~~~~~~~~~~~
User permissions are combination of the three base rights: 'READ',
'WRITE' and 'MANAGE'.

[horizontal]
'READ'::   allows to subscribe and read data from the channels
'WRITE'::  allows to trigger backend events and broadcast data on
		   the channels
'MANAGE':: allows to manage the chanels

WEBSOCKETS
----------
The WebSockets server handles communication with the clients
(browsers) over the HTML5WebSockets protocol. WebSockets endpoint
is combined up of a number of parts:

	[scheme]://[host]:[port]/[vhost]

[horizontal]
'scheme':: for a normal connection will be 'ws' and 'wss' for a secure
		   connection.
'host'::   the host of the WebSocket server.
'port'::   the port to connect to.
'vhost'::  the VHost to connect to.

Example
~~~~~~~
Here's an example of the not secured WebSockets URL:

	ws://myhost.com:9772/foo

This layer implements simple JSON-based API for communicating with the clients.

WEBSOCKETS CLIENT EVENTS
------------------------
Communication over the WebSockets protocol has been divided in
two parts: 'client' and 'server' side events. Client side events
are JSON-encoded messages, with the following format:

	{
	    "event": {
	        ... data ...
	    },
	}

[horizontal]
'event':: name of the triggered event
'data'::  payload attached to this event

We can distinguish two types of events: 'system' and 'user' defined.
The 'system' events are always prefixed with double underscore
(eg. `__connected`) and used to inform the client about the server
operations. The 'user' events are just custom payloads, which user
can handle in his desired way.

Here's the list of the 'system' events produced by WebSockets server:
	
__CONNECTED
~~~~~~~~~~~
When the connection is successfully established, server sends
an event which contains an unique session id ('sid'):

Format
^^^^^^
	{
	    "__connected": {
	        "sid": "session-id"
	    }
	}

[horizontal]
'data.sid' (String):: an unique session ID

__AUTHENTICATED
~~~~~~~~~~~~~~~
Triggered when connection has been successfully authenticated as
specified user.

Format
^^^^^^
	{
	    "__authenticated": {
	        "user": "username"
	        "permission": "code"
	    }
	}

[horizontal]
'data.user' (String)::        the name of the user client has been
					   		  authenticated as
'data.permission' (Integer):: the permission code

__SUBSCRIBED
~~~~~~~~~~~~
Triggered when the client successfully subscribed specified channel.

Format
^^^^^^
	{
	    "__subscribed": {
	        "channel": "channel-name"
	    }
	}

[horizontal]
'data.channel' (String):: the name of the subscribed channel

__UNSUBSCRIBED
~~~~~~~~~~~~~~
Triggered when the client successfully unsubscribed specified channel.

Format
^^^^^^
	{
	    "__unsubscribed": {
	        "channel": "channel-name"
	    }
	}

[horizontal]
'data.channel' (String):: the name of the unsubscribed channel
	
__BROADCASTED
~~~~~~~~~~~~~
Triggered when data sent by the client has been successfully
broadcasted to the channel's subscribers.

Format
^^^^^^
	{
	    "__broadcasted": {
	        "channel": "channel-name"
	    }
	}

[horizontal]
'data.channel' (String):: the name of the channel to which the data
			   			  has been broadcasted

__TRIGGERED
~~~~~~~~~~~
Called when requested backend event has been successfully triggered.

Format
^^^^^^
	{
	    "__tigerred": {
	        "event": "event-name"
	    }
	}

[horizontal]
'data.event' (String):: the name of the triggered backend event

__ERROR
~~~~~~~
Triggered when server side error occured, or when requested operation
couldn't be processed because of invalid payload or message format.

Format
^^^^^^
	{
	    "__error": {
	        "id": "ERROR_ID"
	    }
	}

[horizontal]
'data.id':: ID of the occured error

WEBSOCKETS SERVER EVENTS
------------------------
All messages incoming from the client should be JSON-encoded as well
and have exactly the same format as the client side messages.

Here's the full list of WebSockets server events.
	
AUTH
~~~~
Authenticates session for the specified user. 

Format
^^^^^^
	{
	    "auth": {
	        "user": "user-name",
	        "secret": "secret"
	    } 
	}

[horizontal]
'user' (String)::              name of the configured user you want to authenticate
'secret' (String) [optional]:: authentication secret for specified user

Errors
^^^^^^
[horizontal]
`INVALID_CREDENTIALS`:: given secret is invalid
`USER_NOT_FOUND`::      given user does not exist
`INVALID_USER_NAME`::   no username given or its format is invalid
`INVALID_PAYLOAD`::     data format is invalid

SUBSCRIBE
~~~~~~~~~
Subscribes client to the specified channel.

Format
^^^^^^
	{
	    "subscribe": {
	        "channel": "channel-name"
	    }
	}

[horizontal]
'channel' (String):: name of the channel you want to subscribe, not existing
					 channels are created automatically

Errors
^^^^^^
[horizontal]
`INVALID_CHANNEL_NAME`:: no channel name given or when given name is invalid
`ACCESS_DENIED`::        current session is not authenticated for reading
`INVALID_PAYLOAD`::      payload format is invalid

UNSUBSCRIBE
~~~~~~~~~~~
Unsubscribes client from the specified channnel.

Format
^^^^^^
	{
	    "unsubscribe": {
	        "channel": "channel-name"
	    }
	}

[horizontal]
'channel' (String):: name of the channel you want to unsubscribe

Errors
^^^^^^
[horizontal]
`INVALID_CHANNEL_NAME`:: no channel name given or when given name is invalid
`CHANNEL_NOT_FOUND`::    given channel doesn't exist
`ACCESS_DENIED`::        current session is not authenticated for reading
`INVALID_PAYLOAD`::      payload format is invalid

BROADCAST
~~~~~~~~~
Broadcasts and triggers client events with specified data on given channels.

Format
^^^^^^
	{
	    "broadcast": {
	        "channel": "channel-name",
	        "event": "event-name",
	        "data": "json-encoded-data"
	    }
	}

[horizontal]
'channel' (String)::         channel have to exist
'event' (String)::           name of the event which will be triggerred on the client side
'data' (String) [optional]:: JSON-encoded string with broadcasted data

Errors
^^^^^^
[horizontal]
`INVALID_EVENT_NAME`::   no event name given or its format is invalid
`INVALID_CHANNEL_NAME`:: no channel name given or its format is invalid
`CHANNEL_NOT_FOUND`::    given channel doesn't exist
`ACCESS_DENIED`::        current session is not authenticated for writing
`INVALID_PAYLOAD`::      payload format is invalid

TRIGGER
~~~~~~~
Sends direct request to server side application.

Format
^^^^^^
	{
	    "trigger": {
	        "event": "event-name",
	        "data": "json-encoded-data"
	    }
	}

[horizontal]
'event' (String)::           name of the event which will be triggerred on the server side
'data' (String) [optional]:: request parameters in JSON-encoded string

Errors
^^^^^^
[horizontal]
`INVALID_EVENT_NAME`:: no event name given
`ASSIGNATION_FAILED`:: there is no active worker which can handle specified request
`ACCESS_DENIED`::      current session is not authenticated for writing
`INVALID_PAYLOAD`::    payload format is invalid

CLOSE
~~~~~
Unsubscribes all channels and safely closes connection.

Format
^^^^^^
	{
	    "close": true
	}

Errors
^^^^^^
[horizontal]
`INVALID_PAYLOAD`:: payload format is invalid

MQ EXCHANGE SERVER
------------------
The MQ exhange Handles communication with the server side applications
and spreads the internal tasks across all nodes using the 'ZeroMQ'
library.

MQ EXCHANGE PROTOCOL
--------------------
The protocol used by the 'MQ exchange' uses the same JSON-encoded
message as in WebSockets server. 

Here's the full list of events supported by the MQ exchange:

AUTH
~~~~
Authenticates current session for the specified user and vhost.

Format
^^^^^^
	{
	    "auth": {
	        "vhost": "vhost-path",
	        "user": "user-name",
	        "secret": "secret"
	    }
	}
	
[horizontal]
'vhost' (String)::             vhost to which user want to be connected to
'user' (String)::              name of the configured user you want to authenticate
'secret' (String) [optional]:: authentication secret for specified user

Errors
^^^^^^
[horizontal]
`VHOST_NOT_FOUND`::     given vhost does not exist
`INVALID_VHOST`::       no vhost given or its format is invalid
`INVALID_CREDENTIALS`:: given secret is invalid
`USER_NOT_FOUND`::      given user does not exist
`INVALID_USER_NAME`::   no username given or its format is invalid
`INVALID_PAYLOAD`::     data format is invalid

BROADCAST
~~~~~~~~~
Broadcasts given JSON data on the specified channel.

Format
^^^^^^
	{
	    "broadcast": {
	        "channel": "channel-name",
	        "event": "event-name",
	        "data": "json-encoded-data"
	    }
	}

[horizontal]
'channel' (String)::         channel name to which data should be broadcasted
'event' (String)::           name of the event which will be triggerred on the client side
'data' (String) [optional]:: JSON-encoded string with broadcasted data

Errors
^^^^^^
[horizontal]
`INVALID_CHANNEL_NAME`:: no channel name given or its format is invalid
`CHANNEL_NOT_FOUND`::    given channel doesn't exist
`ACCESS_DENIED`::        current session is not authenticated for writing
`INVALID_PAYLOAD`::      payload format is invalid

DIRECT
~~~~~~
Sends direct message to specified client.

Format
^^^^^^
	{
	    "direct": {
	        "sid": "session-id",
	        "event": "event-name",
	        "data": "json-encoded-data"
	    }
	}

[horizontal]
'sid' (String)::              session id of the target client
'event' (String)::            name of the event which will be triggerred on the client side
'data' (String) [optional]::  JSON-encoded string with data to send
	
Errors
^^^^^^
[horizontal]
`INVALID_SESSION_ID`:: no session id given or its format is invalid
`SESSION_NOT_FOUND`::  given session doesn't exist 
`ACCESS_DENIED`::      current session is not authenticated for writing
`INVALID_PAYLOAD`::    payload format is invalid

CLOSE
~~~~~
Closes current session and disconnects the client.

Format
^^^^^^
	{
	    "close": true
	}

Errors
^^^^^^
[horizontal]
`INVALID_PAYLOAD`:: payload format is invalid
	
EXAMPLES
--------
Simple server example:

	srv := webrocket.NewServer(":8080")
	echo, _ := srv.AddVhost("/echo")
	echo.AddUser("joe", "secret", PermRead|PermWrite)
	srv.ListenAndServe()

Accessing various data from the 'vhost':

	channels := echo.Channels()
	hello, _ := echo.GetChannel("hello")
	users := echo.Users()
	joe, _ := echo.GetUser("joe")
	conns := echo.Connections()
	ok := echo.IsRunning()
	
Managing users, setting permissions:

	echo.SetUserPermissions("joe", PermRead|PermWrite|PermManage)
	echo.DeleteUser("joe")
	
SEE ALSO
--------
*webrocket-server*(1), *webrocket-ctl*(1), *webrocket-monitor*(1)

AUTHOR
------
Chris Kowalik <chris@nu7hat.ch>
